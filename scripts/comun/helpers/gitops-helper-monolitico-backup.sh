#!/bin/bash
# GitOps Helper - Sistema de optimizaci√≥n din√°mico v3.0.0
# Autodescubrimiento y b√∫squeda de versiones en tiempo real

#!/bin/bash
# ============================================================================
# GITOPS HELPER - Sistema din√°mico de gesti√≥n de herramientas GitOps
# ============================================================================

# Desactivar set -u para evitar errores con variables din√°micas
set +u

# Arrays globales para el sistema din√°mico
GITOPS_TOOLS_DISCOVERED=()
declare -a GITOPS_TOOLS_DISCOVERED
declare -A GITOPS_CHART_INFO

# Funci√≥n para autodescubrir herramientas GitOps en tiempo real
autodescubrir_herramientas_gitops() {
    local directorio_herramientas="herramientas-gitops"
    
    echo "üîç Autodescubriendo herramientas GitOps en $directorio_herramientas..."
    
    # Limpiar arrays din√°micos
    GITOPS_TOOLS_DISCOVERED=()
    # Limpiar array asociativo correctamente
    for key in "${!GITOPS_CHART_INFO[@]}"; do
        unset GITOPS_CHART_INFO["$key"]
    done
    
    # Escanear todos los archivos YAML en herramientas-gitops
    for archivo_yaml in "$directorio_herramientas"/*.yaml; do
        if [[ -f "$archivo_yaml" ]]; then
            local nombre_herramienta=$(basename "$archivo_yaml" .yaml)
            GITOPS_TOOLS_DISCOVERED+=("$nombre_herramienta")
            
            echo "   üì¶ Descubierto: $nombre_herramienta"
            
            # Extraer informaci√≥n del chart del YAML
            extraer_info_chart_del_yaml "$archivo_yaml" "$nombre_herramienta"
        fi
    done
    
    echo "‚úÖ Autodescubrimiento completado: ${#GITOPS_TOOLS_DISCOVERED[@]} herramientas encontradas"
}

# Funci√≥n para extraer informaci√≥n del chart directamente del YAML
extraer_info_chart_del_yaml() {
    local archivo_yaml="$1"
    local herramienta="$2"
    
    echo "   üîç DEBUG: Procesando herramienta='$herramienta' archivo='$archivo_yaml'"
    
    # Buscar informaci√≥n del repositorio Helm en el YAML
    local repo_url=$(grep -E '^\s*repoURL:' "$archivo_yaml" | head -1 | sed 's/.*repoURL:\s*//' | tr -d '"' | tr -d "'")
    local chart_name=$(grep -E '^\s*chart:' "$archivo_yaml" | head -1 | sed 's/.*chart:\s*//' | tr -d '"' | tr -d "'")
    
    echo "   üîç DEBUG: repo_url='$repo_url' chart_name='$chart_name'"
    
    # Si no hay informaci√≥n del chart, intentar deducirla
    if [[ -z "$repo_url" || -z "$chart_name" ]]; then
        echo "   ‚ö†Ô∏è  No se encontr√≥ info de chart en $archivo_yaml, usando detecci√≥n inteligente"
        detectar_chart_inteligente "$herramienta"
    else
        # Extraer nombre del repositorio de la URL - manejo seguro
        local repo_name
        repo_name=$(echo "$repo_url" | sed 's|https://||' | sed 's|\.github\.io/.*||' | sed 's|.*github\.com/||' | sed 's|/.*||' 2>/dev/null || echo "unknown")
        
        echo "   üîç DEBUG: repo_name='$repo_name' antes de asignar al array"
        
        # Usar variables auxiliares para evitar problemas de expansi√≥n con guiones
        local key_repo="${herramienta}_repo"
        local key_chart="${herramienta}_chart"
        local key_repo_url="${herramienta}_repo_url"
        
        GITOPS_CHART_INFO["$key_repo"]="$repo_name"
        GITOPS_CHART_INFO["$key_chart"]="$chart_name"
        GITOPS_CHART_INFO["$key_repo_url"]="$repo_url"
        
        echo "   üìã Chart detectado: $repo_name/$chart_name"
    fi
}

# Funci√≥n de detecci√≥n inteligente de charts
detectar_chart_inteligente() {
    local herramienta="$1"
    
    # Variables auxiliares para evitar problemas de expansi√≥n con guiones
    local key_repo="${herramienta}_repo"
    local key_chart="${herramienta}_chart"
    
    # Base de conocimiento inteligente para detecci√≥n autom√°tica
    case "$herramienta" in
        *"ingress"*|*"nginx"*)
            GITOPS_CHART_INFO["$key_repo"]="ingress-nginx"
            GITOPS_CHART_INFO["$key_chart"]="ingress-nginx"
            ;;
        *"external"*|*"secret"*)
            GITOPS_CHART_INFO["$key_repo"]="external-secrets"
            GITOPS_CHART_INFO["$key_chart"]="external-secrets"
            ;;
        *"cert"*|*"manager"*)
            GITOPS_CHART_INFO["$key_repo"]="jetstack"
            GITOPS_CHART_INFO["$key_chart"]="cert-manager"
            ;;
        *"argo"*"event"*)
            GITOPS_CHART_INFO["$key_repo"]="argo"
            GITOPS_CHART_INFO["$key_chart"]="argo-events"
            ;;
        *"argo"*"workflow"*)
            GITOPS_CHART_INFO["$key_repo"]="argo"
            GITOPS_CHART_INFO["$key_chart"]="argo-workflows"
            ;;
        *"argo"*"rollout"*)
            GITOPS_CHART_INFO["$key_repo"]="argo"
            GITOPS_CHART_INFO["$key_chart"]="argo-rollouts"
            ;;
        *"prometheus"*|*"kube-prometheus-stack"*)
            GITOPS_CHART_INFO["$key_repo"]="prometheus-community"
            GITOPS_CHART_INFO["$key_chart"]="kube-prometheus-stack"
            ;;
        *"grafana"*)
            GITOPS_CHART_INFO["$key_repo"]="grafana"
            GITOPS_CHART_INFO["$key_chart"]="grafana"
            ;;
        *"loki"*)
            GITOPS_CHART_INFO["$key_repo"]="grafana"
            GITOPS_CHART_INFO["$key_chart"]="loki"
            ;;
        *"jaeger"*)
            GITOPS_CHART_INFO["$key_repo"]="jaegertracing"
            GITOPS_CHART_INFO["$key_chart"]="jaeger"
            ;;
        *"minio"*)
            GITOPS_CHART_INFO["$key_repo"]="minio"
            GITOPS_CHART_INFO["$key_chart"]="minio"
            ;;
        *"gitea"*)
            GITOPS_CHART_INFO["$key_repo"]="gitea-charts"
            GITOPS_CHART_INFO["$key_chart"]="gitea"
            ;;
        *"kargo"*)
            GITOPS_CHART_INFO["$key_repo"]="kargo"
            GITOPS_CHART_INFO["$key_chart"]="kargo"
            ;;
        *)
            # Detecci√≥n gen√©rica: usar el nombre de la herramienta
            GITOPS_CHART_INFO["$key_repo"]="$herramienta"
            GITOPS_CHART_INFO["$key_chart"]="$herramienta"
            ;;
    esac
    
    echo "   üß† Detecci√≥n inteligente: ${GITOPS_CHART_INFO[$key_repo]:-unknown}/${GITOPS_CHART_INFO[$key_chart]:-unknown}"
}

# Funci√≥n para buscar la √∫ltima versi√≥n de un chart en tiempo real
buscar_ultima_version_chart() {
    local herramienta="$1"
    local key_repo="${herramienta}_repo"
    local key_chart="${herramienta}_chart"
    local repo="${GITOPS_CHART_INFO[$key_repo]:-}"
    local chart="${GITOPS_CHART_INFO[$key_chart]:-}"
    
    if [[ -z "$repo" || -z "$chart" ]]; then
        echo "latest"
        return
    fi
    
    echo "üîç Buscando versi√≥n m√°s reciente para $herramienta ($repo/$chart)..." >&2
    
    # M√©todo 1: Buscar usando helm search repo (asegurar que el repo existe)
    local version=""
    if helm repo list 2>/dev/null | grep -q "^$repo"; then
        echo "   üì¶ Usando repositorio Helm: $repo" >&2
        version=$(helm search repo "$repo/$chart" --versions 2>/dev/null | awk 'NR==2 {print $2}')
    fi
    
    # M√©todo 2: APIs de GitHub como fallback
    if [[ -z "$version" || "$version" == "No" || "$version" == "CHART" || "$version" == "results" ]]; then
        echo "   üì° Usando API de GitHub como fallback..." >&2
        case "$repo" in
            "ingress-nginx"|"kubernetes")
                version=$(curl -s https://api.github.com/repos/kubernetes/ingress-nginx/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' | sed 's/controller-//' 2>/dev/null)
                ;;
            "jetstack")
                version=$(curl -s https://api.github.com/repos/cert-manager/cert-manager/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                ;;
            "external-secrets")
                version=$(curl -s https://api.github.com/repos/external-secrets/external-secrets/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                ;;
            "argo")
                case "$chart" in
                    "argo-events")
                        version=$(curl -s https://api.github.com/repos/argoproj/argo-events/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                        ;;
                    "argo-workflows")
                        version=$(curl -s https://api.github.com/repos/argoproj/argo-workflows/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                        ;;
                    "argo-rollouts")
                        version=$(curl -s https://api.github.com/repos/argoproj/argo-rollouts/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                        ;;
                esac
                ;;
            "prometheus-community")
                # Para prometheus stack, usar una versi√≥n conocida estable
                version="65.1.1"
                ;;
            "grafana")
                version=$(curl -s https://api.github.com/repos/grafana/grafana/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' | sed 's/v//' 2>/dev/null)
                ;;
            *)
                version="latest"
                ;;
        esac
    fi
    
    # M√©todo 3: Fallback a "latest" si todo falla
    if [[ -z "$version" ]]; then
        version="latest"
    fi
    
    echo "   ‚úÖ Versi√≥n detectada: $version" >&2
    echo "$version"
}

# Funci√≥n para configurar repositorios Helm din√°micamente
configurar_repositorios_helm() {
    echo "üì° Configurando repositorios Helm din√°micamente..."
    
    # Repositorios comunes basados en herramientas descubiertas
    declare -A repos_necesarios
    
    for herramienta in "${GITOPS_TOOLS_DISCOVERED[@]}"; do
        local repo="${GITOPS_CHART_INFO[${herramienta}_repo]}"
        
        case "$repo" in
            "ingress-nginx")
                repos_necesarios["ingress-nginx"]="https://kubernetes.github.io/ingress-nginx"
                ;;
            "jetstack")
                repos_necesarios["jetstack"]="https://charts.jetstack.io"
                ;;
            "external-secrets")
                repos_necesarios["external-secrets"]="https://charts.external-secrets.io"
                ;;
            "argo")
                repos_necesarios["argo"]="https://argoproj.github.io/argo-helm"
                ;;
            "prometheus-community")
                repos_necesarios["prometheus-community"]="https://prometheus-community.github.io/helm-charts"
                ;;
            "grafana")
                repos_necesarios["grafana"]="https://grafana.github.io/helm-charts"
                ;;
            "jaegertracing")
                repos_necesarios["jaegertracing"]="https://jaegertracing.github.io/helm-charts"
                ;;
            "minio")
                repos_necesarios["minio"]="https://charts.min.io/"
                ;;
            "gitea-charts")
                repos_necesarios["gitea-charts"]="https://dl.gitea.io/charts/"
                ;;
            "kargo")
                repos_necesarios["kargo"]="https://charts.kargo.io"
                ;;
        esac
    done
    
    # Agregar repositorios din√°micamente
    for repo_name in "${!repos_necesarios[@]}"; do
        local repo_url="${repos_necesarios[$repo_name]}"
        echo "   üì¶ Agregando repositorio: $repo_name ($repo_url)"
        helm repo add "$repo_name" "$repo_url" >/dev/null 2>&1 || true
    done
    
    echo "   üîÑ Actualizando repositorios..."
    helm repo update >/dev/null 2>&1
    
    echo "‚úÖ Repositorios Helm configurados din√°micamente"
}

# Funci√≥n principal de optimizaci√≥n GitOps din√°mico
ejecutar_optimizacion_gitops() {
    echo "üöÄ Iniciando optimizaci√≥n GitOps v3.0.0 - Sistema autodescubrible"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    # Paso 1: Autodescubrir herramientas
    autodescubrir_herramientas_gitops
    
    if [[ ${#GITOPS_TOOLS_DISCOVERED[@]} -eq 0 ]]; then
        echo "‚ùå No se encontraron herramientas GitOps en herramientas-gitops/"
        return 1
    fi
    
    # Paso 2: Configurar repositorios Helm din√°micamente
    configurar_repositorios_helm
    
    # Paso 3: Optimizar cada herramienta descubierta
    local contador=1
    local total_herramientas=${#GITOPS_TOOLS_DISCOVERED[@]}
    
    for herramienta in "${GITOPS_TOOLS_DISCOVERED[@]}"; do
        echo
        echo "[$contador/$total_herramientas] üõ†Ô∏è  Optimizando: $herramienta"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        
        # Buscar versi√≥n m√°s reciente din√°micamente
        local version_actual=$(buscar_ultima_version_chart "$herramienta")
        
        # Aplicar optimizaciones de desarrollo
        aplicar_optimizaciones_desarrollo "$herramienta" "$version_actual"
        
        ((contador++))
    done
    
    echo
    echo "‚úÖ Optimizaci√≥n GitOps completada din√°micamente"
    echo "üîÑ Sistema autodescubrible activo - nuevos YAMLs se detectar√°n autom√°ticamente"
    echo "üìä Versiones actualizadas din√°micamente desde fuentes oficiales"
    
    # Paso 4: Commit y push de cambios antes de desplegar
    hacer_commit_push_cambios
    
    # Paso 5: Aplicar App of Tools a ArgoCD
    aplicar_app_of_tools
    
    # Paso 6: Esperar a que todas las aplicaciones est√©n Synced y Healthy
    echo
    echo "‚è≥ Esperando a que todas las herramientas GitOps est√©n Synced y Healthy..."
    esperar_aplicaciones_completas
}

# Funci√≥n para esperar a que todas las aplicaciones est√©n Synced y Healthy
esperar_aplicaciones_completas() {
    local max_intentos=60  # 10 minutos m√°ximo (60 intentos x 10 segundos)
    local contador=1
    local aplicaciones_esperadas=(
        "argo-events" "argo-rollouts" "argo-workflows" "cert-manager"
        "external-secrets" "gitea" "grafana" "ingress-nginx" "jaeger"
        "kargo" "loki" "minio" "prometheus-stack"
    )
    
    echo "üéØ Verificando estado de ${#aplicaciones_esperadas[@]} herramientas GitOps..."
    echo "‚ö†Ô∏è  MODO ACTIVO: Diagnosticando y corrigiendo problemas autom√°ticamente"
    
    while [[ $contador -le $max_intentos ]]; do
        echo "[$contador/$max_intentos] üîç Verificando estado de aplicaciones..."
        
        local todas_ok=true
        local aplicaciones_problematicas=()
        local aplicaciones_out_of_sync=()
        local aplicaciones_unhealthy=()
        
        # Verificar cada aplicaci√≥n esperada
        for app in "${aplicaciones_esperadas[@]}"; do
            if ! kubectl get application "$app" -n argocd >/dev/null 2>&1; then
                todas_ok=false
                aplicaciones_problematicas+=("$app:NO_EXISTE")
                continue
            fi
            
            local sync_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            local health_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            if [[ "$sync_status" != "Synced" ]]; then
                todas_ok=false
                aplicaciones_out_of_sync+=("$app")
                aplicaciones_problematicas+=("$app:$sync_status/$health_status")
            elif [[ "$health_status" != "Healthy" ]]; then
                todas_ok=false
                aplicaciones_unhealthy+=("$app")
                aplicaciones_problematicas+=("$app:$sync_status/$health_status")
            fi
        done
        
        if [[ "$todas_ok" == "true" ]]; then
            echo
            echo "‚úÖ ¬°Todas las herramientas GitOps est√°n Synced y Healthy!"
            mostrar_estado_final_aplicaciones
            return 0
        fi
        
        # Mostrar aplicaciones problem√°ticas (solo primeras 5 para no saturar log)
        if [[ ${#aplicaciones_problematicas[@]} -gt 0 ]]; then
            echo "   ‚ö†Ô∏è  Aplicaciones pendientes: ${aplicaciones_problematicas[@]:0:5}"
            if [[ ${#aplicaciones_problematicas[@]} -gt 5 ]]; then
                echo "      ... y $((${#aplicaciones_problematicas[@]} - 5)) m√°s"
            fi
        fi
        
        # CORRECCIONES ACTIVAS cada 3 intentos
        if [[ $((contador % 3)) -eq 0 ]]; then
            echo "   üîß Aplicando correcciones activas..."
            
            # Forzar sincronizaci√≥n de aplicaciones OutOfSync
            if [[ ${#aplicaciones_out_of_sync[@]} -gt 0 ]]; then
                echo "   üîÑ Forzando sincronizaci√≥n de aplicaciones OutOfSync..."
                for app in "${aplicaciones_out_of_sync[@]}"; do
                    echo "      üîÑ Sincronizando: $app"
                    kubectl patch application "$app" -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}' >/dev/null 2>&1 || true
                done
            fi
            
            # Diagnosticar aplicaciones Unhealthy
            if [[ ${#aplicaciones_unhealthy[@]} -gt 0 ]]; then
                echo "   ü©∫ Diagnosticando aplicaciones Unhealthy..."
                diagnosticar_aplicaciones_unhealthy "${aplicaciones_unhealthy[@]}"
            fi
            
            # Verificar App of Tools principal
            verificar_app_of_tools
        fi
        
        # CORRECCI√ìN PROFUNDA cada 10 intentos
        if [[ $((contador % 10)) -eq 0 ]]; then
            echo "   üö® Aplicando correcci√≥n profunda..."
            correccion_profunda_aplicaciones
        fi
        
        echo "   ‚è±Ô∏è  Esperando 10 segundos antes del siguiente chequeo..."
        sleep 10
        ((contador++))
    done
    
    echo
    echo "‚ùå ¬°TIMEOUT! Algunas aplicaciones no llegaron a estar Synced y Healthy"
    echo "üìä Estado final de aplicaciones:"
    mostrar_estado_final_aplicaciones
    echo "üîß Intentando √∫ltima correcci√≥n de emergencia..."
    correccion_emergencia_final
    return 1
}

# Funci√≥n para diagnosticar aplicaciones Unhealthy
diagnosticar_aplicaciones_unhealthy() {
    local aplicaciones_unhealthy=("$@")
    
    for app in "${aplicaciones_unhealthy[@]}"; do
        echo "      ü©∫ Diagnosticando: $app"
        
        # Obtener informaci√≥n del estado
        local mensaje_health=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.message}' 2>/dev/null || echo "")
        local conditions=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.conditions[*].message}' 2>/dev/null || echo "")
        
        echo "         Estado: $mensaje_health"
        if [[ -n "$conditions" ]]; then
            echo "         Condiciones: $conditions"
        fi
        
        # Verificar namespace de destino
        local target_namespace=$(kubectl get application "$app" -n argocd -o jsonpath='{.spec.destination.namespace}' 2>/dev/null || echo "")
        if [[ -n "$target_namespace" ]]; then
            if ! kubectl get namespace "$target_namespace" >/dev/null 2>&1; then
                echo "         üîß Creando namespace faltante: $target_namespace"
                kubectl create namespace "$target_namespace" >/dev/null 2>&1 || true
            fi
        fi
        
        # Verificar recursos del namespace
        if [[ -n "$target_namespace" ]]; then
            local recursos_error=$(kubectl get events -n "$target_namespace" --field-selector type=Warning --no-headers 2>/dev/null | head -3)
            if [[ -n "$recursos_error" ]]; then
                echo "         ‚ö†Ô∏è Eventos de warning en $target_namespace:"
                echo "$recursos_error" | sed 's/^/            /'
            fi
        fi
    done
}

# Funci√≥n para verificar App of Tools
verificar_app_of_tools() {
    echo "   üîç Verificando App of Tools principal..."
    
    if ! kubectl get application app-of-tools-gitops -n argocd >/dev/null 2>&1; then
        echo "   üö® App of Tools no encontrada, reaplicando..."
        if kubectl apply -f argo-apps/app-of-tools-gitops.yaml >/dev/null 2>&1; then
            echo "   ‚úÖ App of Tools reaplicada"
        else
            echo "   ‚ùå Error reaplicando App of Tools"
        fi
    else
        local sync_status=$(kubectl get application app-of-tools-gitops -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
        if [[ "$sync_status" != "Synced" ]]; then
            echo "   üîÑ Forzando sincronizaci√≥n de App of Tools..."
            kubectl patch application app-of-tools-gitops -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}' >/dev/null 2>&1 || true
        fi
    fi
}

# Funci√≥n de correcci√≥n profunda
correccion_profunda_aplicaciones() {
    echo "      üîß Correcci√≥n profunda iniciada..."
    
    # Refresh completo de ArgoCD
    echo "      üîÑ Refrescando repositorio en ArgoCD..."
    kubectl patch application app-of-tools-gitops -n argocd --type merge -p '{"operation":{"refresh":{}}}' >/dev/null 2>&1 || true
    
    # Verificar estado de ArgoCD server
    if ! kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server --no-headers | grep -q Running; then
        echo "      üö® ArgoCD server problem√°tico, reiniciando..."
        kubectl rollout restart deployment argocd-server -n argocd >/dev/null 2>&1 || true
    fi
    
    # Verificar conectividad del repositorio
    echo "      üì° Verificando conectividad del repositorio..."
    local repo_status=$(kubectl get applications -n argocd -o jsonpath='{.items[0].status.sourceType}' 2>/dev/null || echo "")
    if [[ "$repo_status" != "Git" ]]; then
        echo "      ‚ö†Ô∏è Problema de conectividad del repositorio detectado"
    fi
    
    # Limpiar aplicaciones en estado error
    echo "      üßπ Limpiando aplicaciones en estado error..."
    local apps_error=$(kubectl get applications -n argocd -o jsonpath='{range .items[*]}{.metadata.name}:{.status.health.status}{"\n"}{end}' 2>/dev/null | grep ":Unknown\|:Missing" | cut -d: -f1)
    
    if [[ -n "$apps_error" ]]; then
        while read -r app; do
            if [[ -n "$app" ]]; then
                echo "      üîÑ Recreando aplicaci√≥n problem√°tica: $app"
                kubectl patch application "$app" -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"apply":{"force":true},"prune":true}}}}' >/dev/null 2>&1 || true
            fi
        done <<< "$apps_error"
    fi
}

# Funci√≥n de correcci√≥n de emergencia final
correccion_emergencia_final() {
    echo "üö® Ejecutando correcci√≥n de emergencia final..."
    
    # Verificar que al menos las herramientas cr√≠ticas est√©n funcionando
    local herramientas_criticas=("grafana" "prometheus-stack" "ingress-nginx" "cert-manager")
    local criticas_ok=0
    
    for tool in "${herramientas_criticas[@]}"; do
        if kubectl get application "$tool" -n argocd >/dev/null 2>&1; then
            local sync_status=$(kubectl get application "$tool" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            local health_status=$(kubectl get application "$tool" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            if [[ "$sync_status" == "Synced" && "$health_status" == "Healthy" ]]; then
                ((criticas_ok++))
                echo "   ‚úÖ Cr√≠tica OK: $tool"
            else
                echo "   ‚ùå Cr√≠tica PROBLEMA: $tool ($sync_status/$health_status)"
                # √öltimo intento de correcci√≥n
                kubectl patch application "$tool" -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"apply":{"force":true},"prune":true,"selfHeal":true}}}}' >/dev/null 2>&1 || true
            fi
        else
            echo "   ‚ùå Cr√≠tica FALTANTE: $tool"
        fi
    done
    
    echo "üìä Herramientas cr√≠ticas funcionando: $criticas_ok/${#herramientas_criticas[@]}"
    
    if [[ $criticas_ok -ge 2 ]]; then
        echo "‚úÖ Al menos las herramientas cr√≠ticas b√°sicas est√°n funcionando"
        echo "üí° El sistema puede continuar, herramientas adicionales se sincronizar√°n gradualmente"
        return 0
    else
        echo "‚ùå Demasiadas herramientas cr√≠ticas fallando"
        return 1
    fi
}

# Funci√≥n para forzar sincronizaci√≥n de aplicaciones OutOfSync

# Funci√≥n para mostrar estado final detallado de aplicaciones
mostrar_estado_final_aplicaciones() {
    echo
    echo "üìä Estado detallado de todas las herramientas GitOps:"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    local aplicaciones_esperadas=(
        "argo-events" "argo-rollouts" "argo-workflows" "cert-manager"
        "external-secrets" "gitea" "grafana" "ingress-nginx" "jaeger"
        "kargo" "loki" "minio" "prometheus-stack"
    )
    
    local total_apps=${#aplicaciones_esperadas[@]}
    local apps_synced=0
    local apps_healthy=0
    local apps_completas=0
    
    printf "%-18s %-12s %-12s %-15s\n" "APLICACI√ìN" "SYNC" "HEALTH" "ESTADO"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    for app in "${aplicaciones_esperadas[@]}"; do
        if ! kubectl get application "$app" -n argocd >/dev/null 2>&1; then
            printf "%-18s %-12s %-12s %-15s\n" "$app" "NO_EXISTE" "NO_EXISTE" "‚ùå FALTANTE"
            continue
        fi
        
        local sync_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
        local health_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
        
        # Contadores
        [[ "$sync_status" == "Synced" ]] && ((apps_synced++))
        [[ "$health_status" == "Healthy" ]] && ((apps_healthy++))
        [[ "$sync_status" == "Synced" && "$health_status" == "Healthy" ]] && ((apps_completas++))
        
        # Estado visual
        local estado_visual="‚ùå PROBLEMA"
        if [[ "$sync_status" == "Synced" && "$health_status" == "Healthy" ]]; then
            estado_visual="‚úÖ COMPLETO"
        elif [[ "$sync_status" == "Synced" ]]; then
            estado_visual="üîÑ SYNC_OK"
        elif [[ "$health_status" == "Healthy" ]]; then
            estado_visual="‚ö†Ô∏è HEALTH_OK"
        fi
        
        printf "%-18s %-12s %-12s %-15s\n" "$app" "$sync_status" "$health_status" "$estado_visual"
    done
    
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "üìà RESUMEN EJECUTIVO:"
    echo "   üéØ Aplicaciones completas (Synced + Healthy): $apps_completas/$total_apps"
    echo "   üîÑ Aplicaciones sincronizadas: $apps_synced/$total_apps"
    echo "   üíö Aplicaciones saludables: $apps_healthy/$total_apps"
    
    local porcentaje_completas=$((apps_completas * 100 / total_apps))
    echo "   üìä Porcentaje de √©xito: $porcentaje_completas%"
    
    if [[ $apps_completas -eq $total_apps ]]; then
        echo "   üéâ ¬°TODAS LAS HERRAMIENTAS GITOPS EST√ÅN OPERATIVAS!"
    elif [[ $apps_completas -ge $((total_apps * 80 / 100)) ]]; then
        echo "   ‚úÖ La mayor√≠a de herramientas est√°n funcionando correctamente"
    elif [[ $apps_completas -ge $((total_apps * 50 / 100)) ]]; then
        echo "   ‚ö†Ô∏è Aproximadamente la mitad de herramientas est√°n funcionando"
    else
        echo "   ‚ùå La mayor√≠a de herramientas tienen problemas - requiere intervenci√≥n"
    fi
    
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    # Verificar configuraci√≥n multi-cluster
    verificar_configuracion_multicluster
}

# Funci√≥n para verificar que ArgoCD est√© configurado para manejar m√∫ltiples clusters
verificar_configuracion_multicluster() {
    echo
    echo "üåê Verificando configuraci√≥n multi-cluster de ArgoCD..."
    
    local clusters_configurados
    clusters_configurados=$(kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster -o name 2>/dev/null | wc -l)
    
    echo "   üìä Clusters configurados en ArgoCD: $clusters_configurados"
    
    if [[ $clusters_configurados -eq 0 ]]; then
        echo "   ‚ÑπÔ∏è  Solo cluster local configurado (normal para entorno dev)"
        echo "   üí° Para multi-cluster, ejecutar configuraci√≥n adicional en fases posteriores"
    else
        echo "   ‚úÖ Configuraci√≥n multi-cluster detectada"
        echo "   üîç Clusters externos configurados:"
        kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster -o custom-columns="CLUSTER:.metadata.labels.argocd\.argoproj\.io/secret-type,SERVER:.data.server" 2>/dev/null | base64 -d 2>/dev/null || echo "   (Detalles no disponibles)"
    fi
    
    return 0
}

# Funci√≥n para hacer commit y push de los cambios antes del despliegue
hacer_commit_push_cambios() {
    echo
    echo "üîÑ Realizando commit y push de cambios de versiones..."
    
    # Verificar si hay cambios para commitear
    if git diff --quiet && git diff --cached --quiet; then
        echo "‚ÑπÔ∏è  No hay cambios para commitear"
        return 0
    fi
    
    # Mostrar archivos modificados
    echo "üìù Archivos modificados:"
    git status --porcelain | head -10
    
    # Agregar todos los cambios
    echo "üì¶ Agregando cambios al staging..."
    git add .
    
    # Crear commit con mensaje descriptivo
    local fecha=$(date '+%Y-%m-%d %H:%M:%S')
    local mensaje="feat: actualizaci√≥n autom√°tica versiones GitOps - $fecha"
    
    echo "üíæ Creando commit: $mensaje"
    if git commit -m "$mensaje"; then
        echo "‚úÖ Commit creado exitosamente"
        
        # Hacer push a la rama actual
        local rama_actual=$(git branch --show-current)
        echo "üöÄ Haciendo push a rama: $rama_actual"
        
        if git push origin "$rama_actual"; then
            echo "‚úÖ Push completado exitosamente"
            echo "üåê Cambios sincronizados con el repositorio remoto"
            
            # Esperar un momento para que GitHub procese los cambios
            echo "‚è≥ Esperando sincronizaci√≥n con GitHub (5 segundos)..."
            sleep 5
            
            return 0
        else
            echo "‚ùå Error al hacer push"
            echo "‚ö†Ô∏è  Los cambios est√°n commiteados localmente pero no sincronizados"
            return 1
        fi
    else
        echo "‚ùå Error al crear commit"
        return 1
    fi
}

# Funci√≥n para aplicar la App of Tools a ArgoCD
aplicar_app_of_tools() {
    echo
    echo "üöÄ Aplicando App of Tools a ArgoCD..."
    
    local app_tools_file="argo-apps/app-of-tools-gitops.yaml"
    
    if [[ ! -f "$app_tools_file" ]]; then
        echo "‚ùå Archivo $app_tools_file no encontrado"
        return 1
    fi
    
    echo "üìã Aplicando $app_tools_file..."
    if kubectl apply -f "$app_tools_file"; then
        echo "‚úÖ App of Tools aplicada exitosamente"
        
        # Verificar que la aplicaci√≥n se cre√≥
        echo "üîç Verificando aplicaci√≥n en ArgoCD..."
        sleep 3
        if kubectl get application app-of-tools-gitops -n argocd >/dev/null 2>&1; then
            echo "‚úÖ Aplicaci√≥n app-of-tools-gitops creada en ArgoCD"
            
            # Mostrar estado inicial
            echo "üìä Estado inicial de la aplicaci√≥n:"
            kubectl get application app-of-tools-gitops -n argocd -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status" 2>/dev/null || echo "   (Estado a√∫n no disponible)"
        else
            echo "‚ö†Ô∏è Aplicaci√≥n creada pero a√∫n no visible en ArgoCD"
        fi
    else
        echo "‚ùå Error al aplicar App of Tools"
        return 1
    fi
    
    return 0
}

# Funci√≥n para aplicar optimizaciones espec√≠ficas de desarrollo
aplicar_optimizaciones_desarrollo() {
    local herramienta="$1"
    local version="$2"
    local archivo_yaml="herramientas-gitops/${herramienta}.yaml"
    
    echo "   ‚öôÔ∏è  Aplicando optimizaciones de desarrollo..."
    echo "   üì¶ Versi√≥n objetivo: $version"
    
    # Actualizar la versi√≥n en el archivo YAML si es diferente de "latest"
    if [[ "$version" != "latest" && -f "$archivo_yaml" ]]; then
        echo "   üîÑ Actualizando versi√≥n en $archivo_yaml..."
        
        # Crear backup del archivo original
        cp "$archivo_yaml" "${archivo_yaml}.backup"
        
        # Actualizar targetRevision si existe
        if grep -q "targetRevision:" "$archivo_yaml"; then
            sed -i "s/targetRevision:.*/targetRevision: \"$version\"/" "$archivo_yaml"
            echo "   ‚úÖ targetRevision actualizado a: $version"
        else
            echo "   ‚ÑπÔ∏è  No se encontr√≥ targetRevision en el archivo"
        fi
        
        # Verificar si el cambio se aplic√≥
        local version_actualizada=$(grep "targetRevision:" "$archivo_yaml" | sed 's/.*targetRevision:\s*//' | tr -d '"' | tr -d "'")
        if [[ "$version_actualizada" == "$version" ]]; then
            echo "   ‚úÖ Versi√≥n verificada en archivo: $version_actualizada"
            rm -f "${archivo_yaml}.backup"  # Eliminar backup si todo sali√≥ bien
        else
            echo "   ‚ö†Ô∏è  La actualizaci√≥n no se reflej√≥ correctamente"
            mv "${archivo_yaml}.backup" "$archivo_yaml"  # Restaurar backup
        fi
    fi
    
    # Crear directorio para valores de desarrollo si no existe
    local dir_values_dev="herramientas-gitops/values-dev"
    mkdir -p "$dir_values_dev"
    
    # Archivo de valores de desarrollo en el repositorio
    local valores_dev_file="$dir_values_dev/${herramienta}-dev-values.yaml"
    
    # Configuraciones optimizadas basadas en el tipo de herramienta
    case "$herramienta" in
        *"ingress"*|*"nginx"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Ingress NGINX
controller:
  replicaCount: 1
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
  service:
    type: NodePort
  admissionWebhooks:
    enabled: false
EOF
            ;;
        *"prometheus"*|*"kube-prometheus-stack"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Prometheus Stack
prometheus:
  prometheusSpec:
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 1Gi
    retention: 7d
    storageSpec:
      volumeClaimTemplate:
        spec:
          resources:
            requests:
              storage: 2Gi
grafana:
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
  persistence:
    enabled: false
  testFramework:
    enabled: false
  adminPassword: admin123
alertmanager:
  alertmanagerSpec:
    resources:
      requests:
        cpu: 50m
        memory: 64Mi
      limits:
        cpu: 100m
        memory: 128Mi
EOF
            ;;
        *"grafana"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Grafana
adminUser: admin
adminPassword: admin123
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 200m
    memory: 256Mi
persistence:
  enabled: true
  size: 1Gi
testFramework:
  enabled: false
serviceMonitor:
  enabled: false
EOF
            ;;
        *"loki"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Loki
deploymentMode: SingleBinary
loki:
  commonConfig:
    replication_factor: 1
  storage:
    type: filesystem
  auth_enabled: false
singleBinary:
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 200m
      memory: 512Mi
  persistence:
    size: 2Gi
test:
  enabled: false
monitoring:
  selfMonitoring:
    enabled: false
  serviceMonitor:
    enabled: false
EOF
            ;;
        *"jaeger"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Jaeger
provisionDataStore:
  cassandra: false
  elasticsearch: false
allInOne:
  enabled: true
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 200m
      memory: 512Mi
storage:
  type: memory
agent:
  enabled: false
collector:
  enabled: false
query:
  enabled: false
EOF
            ;;
        *"minio"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - MinIO
mode: standalone
rootUser: admin
rootPassword: admin123
replicas: 1
resources:
  requests:
    cpu: 100m
    memory: 256Mi
  limits:
    cpu: 200m
    memory: 512Mi
persistence:
  enabled: true
  size: 2Gi
service:
  type: ClusterIP
consoleService:
  type: ClusterIP
EOF
            ;;
        *"gitea"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Gitea
gitea:
  admin:
    username: admin
    password: admin123
    email: admin@local.dev
  config:
    database:
      DB_TYPE: sqlite3
    session:
      PROVIDER: memory
    cache:
      ENABLED: false
resources:
  requests:
    cpu: 100m
    memory: 256Mi
  limits:
    cpu: 200m
    memory: 512Mi
persistence:
  enabled: true
  size: 2Gi
postgresql:
  enabled: false
mysql:
  enabled: false
EOF
            ;;
        *"cert-manager"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Cert-Manager
installCRDs: true
resources:
  requests:
    cpu: 50m
    memory: 64Mi
  limits:
    cpu: 100m
    memory: 128Mi
webhook:
  resources:
    requests:
      cpu: 20m
      memory: 32Mi
    limits:
      cpu: 50m
      memory: 64Mi
cainjector:
  resources:
    requests:
      cpu: 50m
      memory: 64Mi
    limits:
      cpu: 100m
      memory: 128Mi
EOF
            ;;
        *"external-secrets"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - External Secrets
resources:
  requests:
    cpu: 50m
    memory: 64Mi
  limits:
    cpu: 100m
    memory: 128Mi
replicaCount: 1
webhook:
  resources:
    requests:
      cpu: 20m
      memory: 32Mi
    limits:
      cpu: 50m
      memory: 64Mi
certController:
  resources:
    requests:
      cpu: 20m
      memory: 32Mi
    limits:
      cpu: 50m
      memory: 64Mi
EOF
            ;;
        *"argo"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Argo (Events/Workflows/Rollouts)
controller:
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
server:
  resources:
    requests:
      cpu: 50m
      memory: 64Mi
    limits:
      cpu: 100m
      memory: 128Mi
EOF
            ;;
        *"kargo"*)
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - Kargo
api:
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
controller:
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
webhooksServer:
  resources:
    requests:
      cpu: 50m
      memory: 64Mi
    limits:
      cpu: 100m
      memory: 128Mi
EOF
            ;;
        *)
            # Configuraci√≥n gen√©rica optimizada para desarrollo
            cat > "$valores_dev_file" << EOF
# Configuraci√≥n optimizada para desarrollo - $herramienta
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 200m
    memory: 256Mi
replicaCount: 1
EOF
            ;;
    esac
    
    echo "   üíæ Configuraci√≥n optimizada guardada en $valores_dev_file"
    echo "   üéØ Recursos m√≠nimos aplicados para entorno de desarrollo"
    
    # Actualizar el YAML principal para referenciar los valores de desarrollo
    actualizar_referencia_valores_dev "$archivo_yaml" "$valores_dev_file" "$herramienta"
    
    return 0
}

# Funci√≥n para actualizar la referencia a valores de desarrollo en el YAML principal
actualizar_referencia_valores_dev() {
    local archivo_yaml="$1"
    local valores_dev_file="$2"
    local herramienta="$3"
    
    echo "   üîß Actualizando referencia a valores de desarrollo..."
    
    # Crear backup
    cp "$archivo_yaml" "${archivo_yaml}.backup"
    
    # Buscar si ya existe una secci√≥n helm.valueFiles o helm.values
    if grep -q "helm:" "$archivo_yaml"; then
        # Ya existe secci√≥n helm, agregar/actualizar valueFiles
        if grep -q "valueFiles:" "$archivo_yaml"; then
            echo "   ‚ö†Ô∏è  valueFiles ya existe, verificando contenido..."
        else
            # Agregar valueFiles despu√©s de la secci√≥n helm
            sed -i '/helm:/a\      valueFiles:\n        - values-dev/'$herramienta'-dev-values.yaml' "$archivo_yaml"
            echo "   ‚úÖ Agregada referencia a valores de desarrollo"
        fi
    else
        echo "   ‚ÑπÔ∏è  No se encontr√≥ secci√≥n helm en $archivo_yaml"
        echo "   üí° Para aplicar valores de desarrollo, agregue secci√≥n helm manualmente"
    fi
    
    # Verificar cambios
    if grep -q "values-dev/${herramienta}-dev-values.yaml" "$archivo_yaml"; then
        echo "   ‚úÖ Referencia a valores de desarrollo confirmada"
        rm -f "${archivo_yaml}.backup"
    else
        echo "   ‚ö†Ô∏è  No se pudo agregar la referencia autom√°ticamente"
        mv "${archivo_yaml}.backup" "$archivo_yaml"
    fi
}

# Funci√≥n para mostrar resumen de herramientas descubiertas
mostrar_resumen_herramientas() {
    echo "üìã Resumen de herramientas GitOps autodescubiertas:"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    for herramienta in "${GITOPS_TOOLS_DISCOVERED[@]}"; do
        local repo="${GITOPS_CHART_INFO[${herramienta}_repo]}"
        local chart="${GITOPS_CHART_INFO[${herramienta}_chart]}"
        echo "   üì¶ $herramienta ‚Üí $repo/$chart"
    done
    
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "Total: ${#GITOPS_TOOLS_DISCOVERED[@]} herramientas"
}

