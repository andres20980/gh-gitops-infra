#!/bin/bash
# GitOps Helper - Sistema de optimizaci√≥n din√°mico v3.0.0
# Autodescubrimiento y b√∫squeda de versiones en tiempo real

# Variables globales din√°micas
declare -a GITOPS_TOOLS_DISCOVERED=()
declare -A GITOPS_CHART_INFO=()

# Funci√≥n para autodescubrir herramientas GitOps en tiempo real
autodescubrir_herramientas_gitops() {
    local directorio_herramientas="herramientas-gitops"
    
    echo "üîç Autodescubriendo herramientas GitOps en $directorio_herramientas..."
    
    # Limpiar arrays din√°micos
    GITOPS_TOOLS_DISCOVERED=()
    GITOPS_CHART_INFO=()
    
    # Escanear todos los archivos YAML en herramientas-gitops
    for archivo_yaml in "$directorio_herramientas"/*.yaml; do
        if [[ -f "$archivo_yaml" ]]; then
            local nombre_herramienta=$(basename "$archivo_yaml" .yaml)
            GITOPS_TOOLS_DISCOVERED+=("$nombre_herramienta")
            
            echo "   üì¶ Descubierto: $nombre_herramienta"
            
            # Extraer informaci√≥n del chart del YAML
            extraer_info_chart_del_yaml "$archivo_yaml" "$nombre_herramienta"
        fi
    done
    
    echo "‚úÖ Autodescubrimiento completado: ${#GITOPS_TOOLS_DISCOVERED[@]} herramientas encontradas"
}

# Funci√≥n para extraer informaci√≥n del chart directamente del YAML
extraer_info_chart_del_yaml() {
    local archivo_yaml="$1"
    local herramienta="$2"
    
    # Buscar informaci√≥n del repositorio Helm en el YAML
    local repo_url=$(grep -E '^\s*repoURL:' "$archivo_yaml" | head -1 | sed 's/.*repoURL:\s*//' | tr -d '"' | tr -d "'")
    local chart_name=$(grep -E '^\s*chart:' "$archivo_yaml" | head -1 | sed 's/.*chart:\s*//' | tr -d '"' | tr -d "'")
    
    # Si no hay informaci√≥n del chart, intentar deducirla
    if [[ -z "$repo_url" || -z "$chart_name" ]]; then
        echo "   ‚ö†Ô∏è  No se encontr√≥ info de chart en $archivo_yaml, usando detecci√≥n inteligente"
        detectar_chart_inteligente "$herramienta"
    else
        # Extraer nombre del repositorio de la URL - manejo seguro
        local repo_name
        repo_name=$(echo "$repo_url" | sed 's|https://||' | sed 's|\.github\.io/.*||' | sed 's|.*github\.com/||' | sed 's|/.*||' 2>/dev/null || echo "unknown")
        
        GITOPS_CHART_INFO["${herramienta}_repo"]="$repo_name"
        GITOPS_CHART_INFO["${herramienta}_chart"]="$chart_name"
        GITOPS_CHART_INFO["${herramienta}_repo_url"]="$repo_url"
        
        echo "   üìã Chart detectado: $repo_name/$chart_name"
    fi
}

# Funci√≥n de detecci√≥n inteligente de charts
detectar_chart_inteligente() {
    local herramienta="$1"
    
    # Base de conocimiento inteligente para detecci√≥n autom√°tica
    case "$herramienta" in
        *"ingress"*|*"nginx"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="ingress-nginx"
            GITOPS_CHART_INFO["${herramienta}_chart"]="ingress-nginx"
            ;;
        *"external"*|*"secret"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="external-secrets"
            GITOPS_CHART_INFO["${herramienta}_chart"]="external-secrets"
            ;;
        *"cert"*|*"manager"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="jetstack"
            GITOPS_CHART_INFO["${herramienta}_chart"]="cert-manager"
            ;;
        *"argo"*"event"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="argo"
            GITOPS_CHART_INFO["${herramienta}_chart"]="argo-events"
            ;;
        *"argo"*"workflow"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="argo"
            GITOPS_CHART_INFO["${herramienta}_chart"]="argo-workflows"
            ;;
        *"argo"*"rollout"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="argo"
            GITOPS_CHART_INFO["${herramienta}_chart"]="argo-rollouts"
            ;;
        *"prometheus"*|*"kube-prometheus-stack"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="prometheus-community"
            GITOPS_CHART_INFO["${herramienta}_chart"]="kube-prometheus-stack"
            ;;
        *"grafana"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="grafana"
            GITOPS_CHART_INFO["${herramienta}_chart"]="grafana"
            ;;
        *"loki"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="grafana"
            GITOPS_CHART_INFO["${herramienta}_chart"]="loki"
            ;;
        *"jaeger"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="jaegertracing"
            GITOPS_CHART_INFO["${herramienta}_chart"]="jaeger"
            ;;
        *"minio"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="minio"
            GITOPS_CHART_INFO["${herramienta}_chart"]="minio"
            ;;
        *"gitea"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="gitea-charts"
            GITOPS_CHART_INFO["${herramienta}_chart"]="gitea"
            ;;
        *"kargo"*)
            GITOPS_CHART_INFO["${herramienta}_repo"]="kargo"
            GITOPS_CHART_INFO["${herramienta}_chart"]="kargo"
            ;;
        *)
            # Detecci√≥n gen√©rica: usar el nombre de la herramienta
            GITOPS_CHART_INFO["${herramienta}_repo"]="$herramienta"
            GITOPS_CHART_INFO["${herramienta}_chart"]="$herramienta"
            ;;
    esac
    
    echo "   üß† Detecci√≥n inteligente: ${GITOPS_CHART_INFO[${herramienta}_repo]}/${GITOPS_CHART_INFO[${herramienta}_chart]}"
}

# Funci√≥n para buscar la √∫ltima versi√≥n de un chart en tiempo real
buscar_ultima_version_chart() {
    local herramienta="$1"
    local repo="${GITOPS_CHART_INFO[${herramienta}_repo]}"
    local chart="${GITOPS_CHART_INFO[${herramienta}_chart]}"
    
    if [[ -z "$repo" || -z "$chart" ]]; then
        echo "latest"
        return
    fi
    
    echo "üîç Buscando versi√≥n m√°s reciente para $herramienta ($repo/$chart)..." >&2
    
    # M√©todo 1: Buscar usando helm search repo (asegurar que el repo existe)
    local version=""
    if helm repo list 2>/dev/null | grep -q "^$repo"; then
        echo "   üì¶ Usando repositorio Helm: $repo" >&2
        version=$(helm search repo "$repo/$chart" --versions 2>/dev/null | awk 'NR==2 {print $2}')
    fi
    
    # M√©todo 2: APIs de GitHub como fallback
    if [[ -z "$version" || "$version" == "No" || "$version" == "CHART" || "$version" == "results" ]]; then
        echo "   üì° Usando API de GitHub como fallback..." >&2
        case "$repo" in
            "ingress-nginx"|"kubernetes")
                version=$(curl -s https://api.github.com/repos/kubernetes/ingress-nginx/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' | sed 's/controller-//' 2>/dev/null)
                ;;
            "jetstack")
                version=$(curl -s https://api.github.com/repos/cert-manager/cert-manager/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                ;;
            "external-secrets")
                version=$(curl -s https://api.github.com/repos/external-secrets/external-secrets/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                ;;
            "argo")
                case "$chart" in
                    "argo-events")
                        version=$(curl -s https://api.github.com/repos/argoproj/argo-events/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                        ;;
                    "argo-workflows")
                        version=$(curl -s https://api.github.com/repos/argoproj/argo-workflows/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                        ;;
                    "argo-rollouts")
                        version=$(curl -s https://api.github.com/repos/argoproj/argo-rollouts/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' 2>/dev/null)
                        ;;
                esac
                ;;
            "prometheus-community")
                # Para prometheus stack, usar una versi√≥n conocida estable
                version="65.1.1"
                ;;
            "grafana")
                version=$(curl -s https://api.github.com/repos/grafana/grafana/releases/latest | grep '"tag_name":' | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' | sed 's/v//' 2>/dev/null)
                ;;
            *)
                version="latest"
                ;;
        esac
    fi
    
    # M√©todo 3: Fallback a "latest" si todo falla
    if [[ -z "$version" ]]; then
        version="latest"
    fi
    
    echo "   ‚úÖ Versi√≥n detectada: $version" >&2
    echo "$version"
}

# Funci√≥n para configurar repositorios Helm din√°micamente
configurar_repositorios_helm() {
    echo "üì° Configurando repositorios Helm din√°micamente..."
    
    # Repositorios comunes basados en herramientas descubiertas
    declare -A repos_necesarios
    
    for herramienta in "${GITOPS_TOOLS_DISCOVERED[@]}"; do
        local repo="${GITOPS_CHART_INFO[${herramienta}_repo]}"
        
        case "$repo" in
            "ingress-nginx")
                repos_necesarios["ingress-nginx"]="https://kubernetes.github.io/ingress-nginx"
                ;;
            "jetstack")
                repos_necesarios["jetstack"]="https://charts.jetstack.io"
                ;;
            "external-secrets")
                repos_necesarios["external-secrets"]="https://charts.external-secrets.io"
                ;;
            "argo")
                repos_necesarios["argo"]="https://argoproj.github.io/argo-helm"
                ;;
            "prometheus-community")
                repos_necesarios["prometheus-community"]="https://prometheus-community.github.io/helm-charts"
                ;;
            "grafana")
                repos_necesarios["grafana"]="https://grafana.github.io/helm-charts"
                ;;
            "jaegertracing")
                repos_necesarios["jaegertracing"]="https://jaegertracing.github.io/helm-charts"
                ;;
            "minio")
                repos_necesarios["minio"]="https://charts.min.io/"
                ;;
            "gitea-charts")
                repos_necesarios["gitea-charts"]="https://dl.gitea.io/charts/"
                ;;
            "kargo")
                repos_necesarios["kargo"]="https://charts.kargo.io"
                ;;
        esac
    done
    
    # Agregar repositorios din√°micamente
    for repo_name in "${!repos_necesarios[@]}"; do
        local repo_url="${repos_necesarios[$repo_name]}"
        echo "   üì¶ Agregando repositorio: $repo_name ($repo_url)"
        helm repo add "$repo_name" "$repo_url" >/dev/null 2>&1 || true
    done
    
    echo "   üîÑ Actualizando repositorios..."
    helm repo update >/dev/null 2>&1
    
    echo "‚úÖ Repositorios Helm configurados din√°micamente"
}

# Funci√≥n principal de optimizaci√≥n GitOps din√°mico
ejecutar_optimizacion_gitops() {
    echo "üöÄ Iniciando optimizaci√≥n GitOps v3.0.0 - Sistema autodescubrible"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    # Paso 1: Autodescubrir herramientas
    autodescubrir_herramientas_gitops
    
    if [[ ${#GITOPS_TOOLS_DISCOVERED[@]} -eq 0 ]]; then
        echo "‚ùå No se encontraron herramientas GitOps en herramientas-gitops/"
        return 1
    fi
    
    # Paso 2: Configurar repositorios Helm din√°micamente
    configurar_repositorios_helm
    
    # Paso 3: Optimizar cada herramienta descubierta
    local contador=1
    local total_herramientas=${#GITOPS_TOOLS_DISCOVERED[@]}
    
    for herramienta in "${GITOPS_TOOLS_DISCOVERED[@]}"; do
        echo
        echo "[$contador/$total_herramientas] üõ†Ô∏è  Optimizando: $herramienta"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        
        # Buscar versi√≥n m√°s reciente din√°micamente
        local version_actual=$(buscar_ultima_version_chart "$herramienta")
        
        # Aplicar optimizaciones de desarrollo
        aplicar_optimizaciones_desarrollo "$herramienta" "$version_actual"
        
        ((contador++))
    done
    
    echo
    echo "‚úÖ Optimizaci√≥n GitOps completada din√°micamente"
    echo "üîÑ Sistema autodescubrible activo - nuevos YAMLs se detectar√°n autom√°ticamente"
    echo "üìä Versiones actualizadas din√°micamente desde fuentes oficiales"
    
    # Paso 4: Commit y push de cambios antes de desplegar
    hacer_commit_push_cambios
    
    # Paso 5: Aplicar App of Tools a ArgoCD
    aplicar_app_of_tools
    
    # Paso 6: Esperar a que todas las aplicaciones est√©n Synced y Healthy
    echo
    echo "‚è≥ Esperando a que todas las herramientas GitOps est√©n Synced y Healthy..."
    esperar_aplicaciones_completas
}

# Funci√≥n para esperar a que todas las aplicaciones est√©n Synced y Healthy
esperar_aplicaciones_completas() {
    local max_intentos=60  # 10 minutos m√°ximo (60 intentos x 10 segundos)
    local contador=1
    local aplicaciones_esperadas=(
        "argo-events" "argo-rollouts" "argo-workflows" "cert-manager"
        "external-secrets" "gitea" "grafana" "ingress-nginx" "jaeger"
        "kargo" "loki" "minio" "prometheus-stack"
    )
    
    echo "üéØ Verificando estado de ${#aplicaciones_esperadas[@]} herramientas GitOps..."
    
    while [[ $contador -le $max_intentos ]]; do
        echo "[$contador/$max_intentos] üîç Verificando estado de aplicaciones..."
        
        local todas_ok=true
        local aplicaciones_problematicas=()
        
        # Verificar cada aplicaci√≥n esperada
        for app in "${aplicaciones_esperadas[@]}"; do
            if ! kubectl get application "$app" -n argocd >/dev/null 2>&1; then
                todas_ok=false
                aplicaciones_problematicas+=("$app:NO_EXISTE")
                continue
            fi
            
            local sync_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            local health_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            if [[ "$sync_status" != "Synced" ]] || [[ "$health_status" != "Healthy" ]]; then
                todas_ok=false
                aplicaciones_problematicas+=("$app:$sync_status/$health_status")
            fi
        done
        
        if [[ "$todas_ok" == "true" ]]; then
            echo
            echo "‚úÖ ¬°Todas las herramientas GitOps est√°n Synced y Healthy!"
            mostrar_estado_final_aplicaciones
            return 0
        fi
        
        # Mostrar aplicaciones problem√°ticas (solo primeras 5 para no saturar log)
        if [[ ${#aplicaciones_problematicas[@]} -gt 0 ]]; then
            echo "   ‚ö†Ô∏è  Aplicaciones pendientes: ${aplicaciones_problematicas[@]:0:5}"
            if [[ ${#aplicaciones_problematicas[@]} -gt 5 ]]; then
                echo "      ... y $((${#aplicaciones_problematicas[@]} - 5)) m√°s"
            fi
        fi
        
        # Intentar sincronizaci√≥n autom√°tica cada 5 intentos
        if [[ $((contador % 5)) -eq 0 ]]; then
            echo "   üîÑ Forzando sincronizaci√≥n autom√°tica..."
            forzar_sincronizacion_aplicaciones
        fi
        
        echo "   ‚è±Ô∏è  Esperando 10 segundos antes del siguiente chequeo..."
        sleep 10
        ((contador++))
    done
    
    echo
    echo "‚ùå ¬°TIMEOUT! Algunas aplicaciones no llegaron a estar Synced y Healthy"
    echo "üìä Estado final de aplicaciones:"
    mostrar_estado_final_aplicaciones
    return 1
}

# Funci√≥n para forzar sincronizaci√≥n de aplicaciones OutOfSync
forzar_sincronizacion_aplicaciones() {
    local aplicaciones_out_of_sync
    aplicaciones_out_of_sync=$(kubectl get applications -n argocd -o jsonpath='{range .items[*]}{.metadata.name}:{.status.sync.status}{"\n"}{end}' 2>/dev/null | grep -v ":Synced" | cut -d: -f1)
    
    if [[ -n "$aplicaciones_out_of_sync" ]]; then
        echo "   üîß Sincronizando aplicaciones OutOfSync..."
        while read -r app; do
            if [[ -n "$app" ]]; then
                echo "      üîÑ Sincronizando: $app"
                kubectl patch application "$app" -n argocd --type merge -p '{"operation":{"sync":{}}}' >/dev/null 2>&1 || true
            fi
        done <<< "$aplicaciones_out_of_sync"
    fi
}

# Funci√≥n para mostrar estado final detallado de aplicaciones
mostrar_estado_final_aplicaciones() {
    echo
    echo "üìä Estado final de herramientas GitOps:"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    if kubectl get applications -n argocd >/dev/null 2>&1; then
        kubectl get applications -n argocd -o custom-columns="HERRAMIENTA:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status,VERSION:.spec.source.targetRevision" 2>/dev/null || echo "Error obteniendo estado de aplicaciones"
    else
        echo "‚ùå No se pudo obtener el estado de las aplicaciones"
    fi
    
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    # Verificar configuraci√≥n multi-cluster
    verificar_configuracion_multicluster
}

# Funci√≥n para verificar que ArgoCD est√© configurado para manejar m√∫ltiples clusters
verificar_configuracion_multicluster() {
    echo
    echo "üåê Verificando configuraci√≥n multi-cluster de ArgoCD..."
    
    local clusters_configurados
    clusters_configurados=$(kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster -o name 2>/dev/null | wc -l)
    
    echo "   üìä Clusters configurados en ArgoCD: $clusters_configurados"
    
    if [[ $clusters_configurados -eq 0 ]]; then
        echo "   ‚ÑπÔ∏è  Solo cluster local configurado (normal para entorno dev)"
        echo "   üí° Para multi-cluster, ejecutar configuraci√≥n adicional en fases posteriores"
    else
        echo "   ‚úÖ Configuraci√≥n multi-cluster detectada"
        echo "   üîç Clusters externos configurados:"
        kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster -o custom-columns="CLUSTER:.metadata.labels.argocd\.argoproj\.io/secret-type,SERVER:.data.server" 2>/dev/null | base64 -d 2>/dev/null || echo "   (Detalles no disponibles)"
    fi
    
    return 0
}

# Funci√≥n para hacer commit y push de los cambios antes del despliegue
hacer_commit_push_cambios() {
    echo
    echo "üîÑ Realizando commit y push de cambios de versiones..."
    
    # Verificar si hay cambios para commitear
    if git diff --quiet && git diff --cached --quiet; then
        echo "‚ÑπÔ∏è  No hay cambios para commitear"
        return 0
    fi
    
    # Mostrar archivos modificados
    echo "üìù Archivos modificados:"
    git status --porcelain | head -10
    
    # Agregar todos los cambios
    echo "üì¶ Agregando cambios al staging..."
    git add .
    
    # Crear commit con mensaje descriptivo
    local fecha=$(date '+%Y-%m-%d %H:%M:%S')
    local mensaje="feat: actualizaci√≥n autom√°tica versiones GitOps - $fecha"
    
    echo "üíæ Creando commit: $mensaje"
    if git commit -m "$mensaje"; then
        echo "‚úÖ Commit creado exitosamente"
        
        # Hacer push a la rama actual
        local rama_actual=$(git branch --show-current)
        echo "üöÄ Haciendo push a rama: $rama_actual"
        
        if git push origin "$rama_actual"; then
            echo "‚úÖ Push completado exitosamente"
            echo "üåê Cambios sincronizados con el repositorio remoto"
            
            # Esperar un momento para que GitHub procese los cambios
            echo "‚è≥ Esperando sincronizaci√≥n con GitHub (5 segundos)..."
            sleep 5
            
            return 0
        else
            echo "‚ùå Error al hacer push"
            echo "‚ö†Ô∏è  Los cambios est√°n commiteados localmente pero no sincronizados"
            return 1
        fi
    else
        echo "‚ùå Error al crear commit"
        return 1
    fi
}

# Funci√≥n para aplicar la App of Tools a ArgoCD
aplicar_app_of_tools() {
    echo
    echo "üöÄ Aplicando App of Tools a ArgoCD..."
    
    local app_tools_file="argo-apps/app-of-tools-gitops.yaml"
    
    if [[ ! -f "$app_tools_file" ]]; then
        echo "‚ùå Archivo $app_tools_file no encontrado"
        return 1
    fi
    
    echo "üìã Aplicando $app_tools_file..."
    if kubectl apply -f "$app_tools_file"; then
        echo "‚úÖ App of Tools aplicada exitosamente"
        
        # Verificar que la aplicaci√≥n se cre√≥
        echo "üîç Verificando aplicaci√≥n en ArgoCD..."
        sleep 3
        if kubectl get application app-of-tools-gitops -n argocd >/dev/null 2>&1; then
            echo "‚úÖ Aplicaci√≥n app-of-tools-gitops creada en ArgoCD"
            
            # Mostrar estado inicial
            echo "üìä Estado inicial de la aplicaci√≥n:"
            kubectl get application app-of-tools-gitops -n argocd -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status" 2>/dev/null || echo "   (Estado a√∫n no disponible)"
        else
            echo "‚ö†Ô∏è Aplicaci√≥n creada pero a√∫n no visible en ArgoCD"
        fi
    else
        echo "‚ùå Error al aplicar App of Tools"
        return 1
    fi
    
    return 0
}

# Funci√≥n para aplicar optimizaciones espec√≠ficas de desarrollo
aplicar_optimizaciones_desarrollo() {
    local herramienta="$1"
    local version="$2"
    local archivo_yaml="herramientas-gitops/${herramienta}.yaml"
    
    echo "   ‚öôÔ∏è  Aplicando optimizaciones de desarrollo..."
    echo "   üì¶ Versi√≥n objetivo: $version"
    
    # Actualizar la versi√≥n en el archivo YAML si es diferente de "latest"
    if [[ "$version" != "latest" && -f "$archivo_yaml" ]]; then
        echo "   üîÑ Actualizando versi√≥n en $archivo_yaml..."
        
        # Crear backup del archivo original
        cp "$archivo_yaml" "${archivo_yaml}.backup"
        
        # Actualizar targetRevision si existe
        if grep -q "targetRevision:" "$archivo_yaml"; then
            sed -i "s/targetRevision:.*/targetRevision: \"$version\"/" "$archivo_yaml"
            echo "   ‚úÖ targetRevision actualizado a: $version"
        else
            echo "   ‚ÑπÔ∏è  No se encontr√≥ targetRevision en el archivo"
        fi
        
        # Verificar si el cambio se aplic√≥
        local version_actualizada=$(grep "targetRevision:" "$archivo_yaml" | sed 's/.*targetRevision:\s*//' | tr -d '"' | tr -d "'")
        if [[ "$version_actualizada" == "$version" ]]; then
            echo "   ‚úÖ Versi√≥n verificada en archivo: $version_actualizada"
            rm -f "${archivo_yaml}.backup"  # Eliminar backup si todo sali√≥ bien
        else
            echo "   ‚ö†Ô∏è  La actualizaci√≥n no se reflej√≥ correctamente"
            mv "${archivo_yaml}.backup" "$archivo_yaml"  # Restaurar backup
        fi
    fi
    
    # Crear archivo temporal con valores optimizados
    local valores_temp="/tmp/${herramienta}-dev-values.yaml"
    
    # Configuraciones optimizadas basadas en el tipo de herramienta
    case "$herramienta" in
        *"ingress"*|*"nginx"*)
            cat > "$valores_temp" << EOF
controller:
  replicaCount: 1
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
EOF
            ;;
        *"prometheus"*|*"kube-prometheus-stack"*)
            cat > "$valores_temp" << EOF
prometheus:
  prometheusSpec:
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 1Gi
    retention: 7d
grafana:
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi
  persistence:
    enabled: false
EOF
            ;;
        *"grafana"*)
            cat > "$valores_temp" << EOF
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 200m
    memory: 256Mi
persistence:
  enabled: false
testFramework:
  enabled: false
EOF
            ;;
        *)
            # Configuraci√≥n gen√©rica optimizada para desarrollo
            cat > "$valores_temp" << EOF
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 200m
    memory: 256Mi
replicaCount: 1
EOF
            ;;
    esac
    
    echo "   üíæ Configuraci√≥n optimizada guardada en $valores_temp"
    echo "   üéØ Recursos m√≠nimos aplicados para entorno de desarrollo"
    
    return 0
}

# Funci√≥n para mostrar resumen de herramientas descubiertas
mostrar_resumen_herramientas() {
    echo "üìã Resumen de herramientas GitOps autodescubiertas:"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    for herramienta in "${GITOPS_TOOLS_DISCOVERED[@]}"; do
        local repo="${GITOPS_CHART_INFO[${herramienta}_repo]}"
        local chart="${GITOPS_CHART_INFO[${herramienta}_chart]}"
        echo "   üì¶ $herramienta ‚Üí $repo/$chart"
    done
    
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "Total: ${#GITOPS_TOOLS_DISCOVERED[@]} herramientas"
}

